import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as t,a as e}from"./app-Bo7iuh3n.js";const s={},i=e(`<h2 id="作用域和作用域链-scope-chain" tabindex="-1"><a class="header-anchor" href="#作用域和作用域链-scope-chain"><span>作用域和作用域链（Scope Chain）</span></a></h2><p>当进入到一个执行上下文时，上下文也会关联一个作用域链</p><ul><li>作用域链是一个对象列表，用于变量标识符的求值；</li><li>当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象；</li></ul><h2 id="javascript内存管理" tabindex="-1"><a class="header-anchor" href="#javascript内存管理"><span>JavaScript内存管理</span></a></h2><p>不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要手动的管理内存，某些编程语言会自动帮助我们管理内存</p><p>不管以什么样的方式来管理内存，内存的管理都会有如下的生命周期：</p><ul><li>分配申请你需要的内存（申请）</li><li>使用分配的内存（存放一些东西，比如对象等）</li><li>不需要使用时，对其进行释放</li></ul><p>不同的编程语言对于申请和释放会有不同的实现</p><ul><li>手动管理内存：比如C、C++</li><li>自动管理内存：比如Java、JavaScript、Python、Swift、Dart</li></ul><p>内存分配方式</p><ul><li>Js对于原始数据类型内存的分配会在执行时，直接在栈空间进行分配；</li><li>Js对于复杂数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用</li></ul><h2 id="javascript的垃圾回收" tabindex="-1"><a class="header-anchor" href="#javascript的垃圾回收"><span>JavaScript的垃圾回收</span></a></h2><p>因为内存的大小是有限的，所以当内存不在需要的时候，我们需要对其进行释放，以便腾出更多的内存空间</p><p>在手动管理内存的语言中，我们需要通过一些方式自己来释放不在需要的内存，比如free函数：</p><ul><li>但是这种管理的方式其实非常非常的低效，影响我们编写逻辑的代码的效率；</li><li>并且这种方式对开发者的要求也很高，并且一不小心就会产生内存泄漏；</li></ul><p>所以大部分现代的编程语言都是有自己的垃圾回收机制：</p><ul><li>垃圾回收的英文是Garbage Collection，简称GC；</li><li>对于那些不再使用的对象，我们都称之为垃圾，它需要被回收，以释放更多的内存空间；</li><li>而我们的语言运行环境，比如Java的运行环境JVM，JavaScript的运行环境js引擎都会内存垃圾回收器</li><li>垃圾回收器我们也会简称为GC，所以在很多地方你可以看到GC其实指的是垃圾回收器。</li></ul><p>常见的GC算法--引用计数（Reference counting）</p><ul><li>当一个对象有一个引用指向它时，那么这个对象的引用就+1；</li><li>当一个对象的引用为0时，这个对象就可以被销毁掉；</li></ul><p>这个算法有一个很大的弊端就是会产生循环引用；</p><p>常见的GC算法-- 标记清除（mark sweep）</p><ul><li>标记清除的核心思路是可达性</li><li>这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有用到的对象，就认为是不可用的对象</li><li>这个算法可以很好的解决循环引用的问题</li></ul><p>JS引擎比较广泛的采用的就是可达性中的标记清除算法，当然类似于V8引擎为了进行更好的优化，它在算法的实现细节上也会结合一些其他的算法。</p><p>标记整理（Mark compact），和“标记 - 清除”相似</p><ul><li>不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存碎片化。</li></ul><p>分代收集（Generational collection） 对象被分成两组：新的和旧的</p><ul><li>许多对象出现，完成它们的工作并很快死去，它们可以很快被清理；</li><li>那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少</li></ul><p>增量收集（Incremental collection）</p><ul><li>如果有很多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。</li><li>所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分会逐一进行处理，这样会有许多微笑的延迟而不是一个大的延迟。</li></ul><p>闲时收集（Idle time collection） 垃圾收集器只会在CPU空闲时尝试运行，以减少可能对代码执行的影响。</p><h2 id="闭包的概念理解" tabindex="-1"><a class="header-anchor" href="#闭包的概念理解"><span>闭包的概念理解</span></a></h2><p>计算机科学中对闭包的定义</p><ul><li>闭包（Closure），又称语法闭包或函数闭包</li><li>是在支持头等函数的编程语言中，实现语法绑定的一种技术；</li><li>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境</li><li>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即使脱离了捕捉的上下文，它也能照常运行。</li></ul><p>MDN对闭包的解释</p><ul><li>闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。</li><li>换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。</li><li>在JavaScript中，每当创建一个函数，闭包就会在函数创建时的同时被创建出来。</li></ul><h2 id="闭包的内存泄露" tabindex="-1"><a class="header-anchor" href="#闭包的内存泄露"><span>闭包的内存泄露</span></a></h2><p>当一些闭包被创建后，如果之后不再需要使用，可以将其置为空。</p><p>浏览器优化，向下面的job如果在闭包中没有用到，是不会存储的</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&#39;xiaoming&#39;</span>
  <span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token keyword">var</span> job <span class="token operator">=</span> <span class="token string">&#39;it worker&#39;</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">name is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, age is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,39),l=[i];function p(o,c){return n(),t("div",null,l)}const d=a(s,[["render",p],["__file","作用域-闭包.html.vue"]]),m=JSON.parse('{"path":"/web/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85.html","title":"作用域-作用域链-闭包","lang":"zh-CN","frontmatter":{"title":"作用域-作用域链-闭包","icon":"object-group","excerpt":"世界上最宽阔的是海洋，比海洋更宽阔的是天空，比天空更宽阔的是人的心灵 --雨果（法国）","excerptLength":100,"category":["JavaScript"],"tag":["基础"],"description":"作用域和作用域链（Scope Chain） 当进入到一个执行上下文时，上下文也会关联一个作用域链 作用域链是一个对象列表，用于变量标识符的求值； 当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象； JavaScript内存管理 不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要手动的管...","head":[["meta",{"property":"og:url","content":"https://arisemarcher.github.io/blog/blog/web/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85.html"}],["meta",{"property":"og:site_name","content":"御神"}],["meta",{"property":"og:title","content":"作用域-作用域链-闭包"}],["meta",{"property":"og:description","content":"作用域和作用域链（Scope Chain） 当进入到一个执行上下文时，上下文也会关联一个作用域链 作用域链是一个对象列表，用于变量标识符的求值； 当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象； JavaScript内存管理 不管什么样的编程语言，在代码的执行过程中都是需要给它分配内存的，不同的是某些编程语言需要手动的管..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-07T04:08:07.000Z"}],["meta",{"property":"article:tag","content":"基础"}],["meta",{"property":"article:modified_time","content":"2024-04-07T04:08:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"作用域-作用域链-闭包\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-07T04:08:07.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"作用域和作用域链（Scope Chain）","slug":"作用域和作用域链-scope-chain","link":"#作用域和作用域链-scope-chain","children":[]},{"level":2,"title":"JavaScript内存管理","slug":"javascript内存管理","link":"#javascript内存管理","children":[]},{"level":2,"title":"JavaScript的垃圾回收","slug":"javascript的垃圾回收","link":"#javascript的垃圾回收","children":[]},{"level":2,"title":"闭包的概念理解","slug":"闭包的概念理解","link":"#闭包的概念理解","children":[]},{"level":2,"title":"闭包的内存泄露","slug":"闭包的内存泄露","link":"#闭包的内存泄露","children":[]}],"git":{"createdTime":1711251408000,"updatedTime":1712462887000,"contributors":[{"name":"arisemarcher","email":"2543061999@qq.com","commits":3}]},"readingTime":{"minutes":5.16,"words":1547},"filePathRelative":"web/JavaScript/作用域-闭包.md","localizedDate":"2024年3月24日","autoDesc":true}');export{d as comp,m as data};
